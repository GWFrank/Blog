I"ï<!-- # ItC Week 3~4 - Boolean Logic -->

<!-- ###### tags: `Intro_to_Comp` -->

<ul>
  <li>
    <h2 id="introduction">Introduction</h2>

    <ul>
      <li>Specifications for time(clock)</li>
    </ul>
  </li>
  <li>
    <h2 id="logic-circuits">Logic Circuits</h2>

    <ul>
      <li>Combiniational Logic
        <ul>
          <li>memoryless</li>
          <li>output instantly be effected by current inputs</li>
        </ul>
      </li>
      <li>Sequential Logic
        <ul>
          <li>has memory</li>
          <li>output be effected by current &amp; previous inputs</li>
        </ul>
      </li>
      <li>Combinational Compositions
        <ul>
          <li>every element is combinational</li>
          <li>no cyclic path</li>
          <li>every node is either an input or connect to exactly 1 output</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h2 id="boolean-equation">Boolean Equation</h2>

    <ul>
      <li>Half Adder</li>
      <li>Truth Table</li>
      <li>$+ \rightarrow or$</li>
      <li>$\cdot \rightarrow and$</li>
      <li>Sum-of-Products(SOP) Form
        <ul>
          <li>all equations can be written in SOP form</li>
          <li>solution is guaranteed but not optimized</li>
        </ul>
      </li>
      <li>Producto-of-Sum(POS) Form
        <ul>
          <li>similar to SOP, solution is guaranteed but not optimized</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h2 id="boolean-algebra">Boolean Algebra</h2>

    <ul>
      <li>Idendity Theorem
        <ul>
          <li>$B \cdot 1 = B$</li>
          <li>$B + 0 = B$</li>
        </ul>
      </li>
      <li>Null Element Theorem
        <ul>
          <li>$B \cdot 0 = 0$</li>
          <li>$B + 1=1$</li>
        </ul>
      </li>
      <li>Idempotency Theorem
        <ul>
          <li>$B \cdot B = B$</li>
          <li>$B + B = B$</li>
        </ul>
      </li>
      <li>Involution Theorem
        <ul>
          <li>$\overline{\overline B}=B$</li>
        </ul>
      </li>
      <li>Complement Theorem
        <ul>
          <li>$B \cdot \overline B = 0$</li>
          <li>$B + \overline B = 1$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h2 id="boolean-theorems-of-several-variables">Boolean Theorems of Several Variables</h2>

    <ul>
      <li>Commutativity(‰∫§ÊèõÂæã)</li>
      <li>Associativity(ÁµêÂêàÂæã)</li>
      <li>Distributivity(ÂàÜÈÖçÂæã)</li>
      <li>Covering</li>
      <li>Consensus(ÂÖ±Ë≠ò)</li>
      <li>De Morgan‚Äôs Theorem
        <ul>
          <li>$\overline {ABCD}=\overline A+\overline B+\overline C+\overline D$</li>
          <li>$\overline {A+B+C+D} = \overline A \cdot \overline B \cdot \overline C \cdot\overline D$</li>
        </ul>
      </li>
      <li>Bubble Pushing
        <ul>
          <li>start pushing from output, then work towards input</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h2 id="from-logic-to-gates">From Logic to Gates</h2>

    <ul>
      <li>Circuit Schematics
        <ul>
          <li>inputs on left(or top)</li>
          <li>outputs on right(or bottom)</li>
          <li>gates flow from left to right</li>
          <li>straight wires are preferred</li>
        </ul>
      </li>
      <li>Contention
        <ul>
          <li>marked as ‚ÄúX‚Äù</li>
          <li>circuit tries to drive output to 1 and 0</li>
        </ul>
      </li>
      <li>Tristate Buffer
| E  | A | Out |
| ‚Äì | - | ‚Äî |
| 0  | 0 | Z   |
| 0  | 1 | Z   |
| 1  | 0 | 0   |
| 1  | 1 | 1   |</li>
      <li>Busses
        <ul>
          <li>connect different components in a computer(CPU, GPU, RAM etc.)</li>
          <li>only one device is active at once</li>
          <li>tristate buffers are commonly used here</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h2 id="k-maps">K-Maps</h2>

    <ul>
      <li>Features
        <ul>
          <li>Minimize boolean equations graphically by combining terms</li>
          <li>$PA+P\overline A=P$</li>
          <li>Can handle up to 4 inputs</li>
        </ul>
      </li>
      <li>Rules
        <ul>
          <li>Bit order in (00, 01, 11, 10), so that adjacent rows/ columns only
differ in 1 bit</li>
          <li>Every 1 must be ‚Äúcircled‚Äù at least once (can be more than once)</li>
          <li>Each circle must span $2^x$ squares in each direction</li>
          <li>Each circle must be as large as possible</li>
          <li>A ‚Äúdon‚Äôt care‚Äù is only cirlced when it helps minimizing the equation</li>
          <li>The map can be transform in to a torus(donut shape)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <h2 id="combinaitonal-building-blocks">Combinaitonal building blocks</h2>

    <ul>
      <li>Multiplexer
        <ul>
          <li>Select between one of $N$ inputs to output</li>
          <li>$log_2 N$-bits select input</li>
          <li>Implementation
            <ul>
              <li>Logic gates</li>
              <li>Tristates</li>
            </ul>
          </li>
          <li>4:1 Mutiplexer implementation
            <ul>
              <li>Logic gates</li>
              <li>Tristates</li>
              <li>2:1 multiplexer</li>
            </ul>
          </li>
          <li>Application
            <ul>
              <li>As a look up table
                <ul>
                  <li><del>Just plug it in(TM)</del></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Decoder
        <ul>
          <li>$N$ inputs, $2^N$ outputs</li>
          <li>Only outpt HIGH on one output</li>
          <li>Example
            <ul>
              <li>memory locator (input = address, output = physical memory)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
:ET